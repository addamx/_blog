[code <Javascript 设计模式>]https://github.com/Apress/pro-javascript-design-patterns.git



# 接口 / Interface
- 注释法
- 属性检查法
- 鸭式辨型法

以下设计模式依赖接口:
1. 工厂模式
2. 组合模式
3. 装饰者模式
4. 命令模式



# 封装

- **静态方法/属性**: 类仅有. 静态属性无法再改变; | 不继承
- **私有方法/属性**: 实例都有一份, 通过特权方法访问私有属性; | 继承
- **特权方法**: 实例都有一份(所以比较占内存), 访问私有属性; | 继承
- **私有静态属性/方法**: 共享, 私有静态属性一般用来记录类的信息; | 继承, 但子父类都会共享属性值;

**私有方法** 对比 **私有静态方法**:
私有方法会创建副本占内存;  私有静态方法尽量替代私有方法, 因为它会被共享(但是无法访问实例的私有属性);
```js
book.getPrivateFun() === book1.getPrivateFun(); //false
book.getPrivateStaticFun() === book1.getPrivateStaticFun(); //true
```
**私有属性**, **私有静态属性**, **静态属性**:
私有属性是实例都有一份. 私有静态属性是共享的. 静态属性无法改变(用类/实例的方法改变), 一般不会用;

```js
/**
 * ES5 实现 公共属性, 公共方法, 私有属性, 私有方法, 私有静态属性, 私有静态方法, 公共静态方法;
 */
var Book = (function() {

  //私有静态属性
  var numOfBooks = 0;

  //私有静态方法: 不能访问私有属性, 但省内存;
  function _isBook() {
    /*...*/
  }

  // constructor
  return function(author) {
    //私有属性
    var title = author + 'title';

    //私有方法: 能访问私有属性, 但占内存;
    function _checkTitle() {
      console.log('私有方法');
    }

    //公共属性
    this.author = author;

    //特权方法:实例访问私有属性
    this.getTitle = function() {
      return title;
    }

    this.test = function() {
      console.log(numOfBooks);
      console.log(_isBook);
      console.log(_checkTitle);
    }

    this.getPrivateFun = function() {
      return _checkTitle;
    }
    this.getPrivateStaticFun = function() {
      return _isBook;
    }

    numOfBooks++;
    if (numOfBooks > 3) {
      throw new Error('Book: Only 3 instances of Book can be created.');
    }
  }
})();


//静态方法
Book.formatTitle = function() {
  console.log('公共静态方法');
}
//静态属性
Book.name = 'Book';

//公共方法
Book.prototype = {
  display: function(){
    console.log('公共方法');
  }
}

var book = new Book('Tom');
var book1 = new Book('Tom1');
```


ES6 仅实现了静态方法, 且**可以被子类继承**;  ES6还没实现静态属性和私有属性/方法;
```js
class Book {
  static formatTitle() {
  }
}
```


# 继承
1. 类式继承
2. 原型式继承
3. 摻进类(mixin)
## 类式继承

ES5
```js
// subClass.prototype = new superClass()会重复执行了superClass的constructor;
//ES3
function extend(subClass, superClass) {
  var F = function() {};
  F.prototype = superClass.prototype;
  subClass.prototype = new F();
  subClass.prototype.constructor = subClass;  //修正constructor
  subClass.superClass = superClass.prototype;  //新增superClass属性指向父类原型;
  if(superClass.prototype.constructor == Object.prototype.constructor) {
    superClass.protottype.constructor = superClass;
  }
}
//ES5
function extend(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.superClass = superClass.prototype;
  if(superClass.prototype.constructor == Object.prototype.constructor) {
    superClass.prototype.constructor = superClass;
  }
}

var Person = function(name) {
  this.name = name;
};

var Man = function(name) {
  Man.superClass.constructor(this, name);
};

extend(Man, Person);
```
## 原型式继承

```js
var Person = {
  name: 'default name',
  friend: ['Tom'],
  addition: {age: 16},
  getName: function() {
    return this.name;
  }
}

function clone(object) {
  function F() {}
  F.prototype = object;
  return new F();
}

var Man = clone(Person);
//错误, 会影响Person
//Man.addition.age = 18; Man.friend.push('Jim');
//正确, 字面量赋予新址
Man.addition = {age: 18}; Man.friend = ['Tom', 'Jim'];
```

## 掺元类(mixin)

```js
function mixin(receivingClass, givingClass) {
  //mixin(Man, Person, 'speak'), 当参数多余2时, 表示仅掺入指定方法;
  if(arguments[2]) {
    for(var i = 2, len = arguments.length; i < len; i++) {
      receivingCLass.prototype[arugments[i]] = givingClass.prototype[arguments[i]];
    }
  } else {
    for (methodName in givingClass.prototype) {
      if(!receivingClass.prototype[methodName]) {
        receivingCLass.prototype[methodName] = givingClass.prototype[methodName];
      }
    }
  }

}
```



# 单体模式
私有方法的一个缺点是占内存, 但由于单体对象只会被实例化一次, 所以创建私有方法很适合.

1. 模块模式
2. 惰性实例化
3. 分支

## 模块模式
类似字面量;

```js
Singleton = (function() {
  //Private members
  var privateAttr = false;

  function privateMethod() {
    console.log('privateMethod');
  }

  //Public members
  return {
    publiceAttr: true,
    publiceMethod: function() {
      console.log('publiceMethod');
    }
  }
})();
```

## 惰性实例化
具有唯一的实例化方法`getInstance`

```js
var Singleton = (function(){
  //保存唯一的实例
  var uniqueInstance;
  //构造函数
  function constructor(arg) {
    var privateAttr = arg;

    function privateMethod() {
      console.log('privateMethod');
    }
    
    return {
      publicAttr: 'privateAttr:' + privateAttr,
      publiceMethod: function() {
        privateMethod();
        console.log(privateAttr);
      }
    }
  }

  return {
    getInstance: function(arg) {
      if(!uniqueInstance) {
        uniqueInstance = constructor(arg);
      }
      return uniqueInstance;
    }
  }
})();

//使用
var s = Singleton.getInstance('Tom');
var z = Singleton.getInstance('Jim');
s === z; //true
z.publicAttr; //privateAttr: Tom

```

## 分支
根据环境条件生成需要的对象. 优点是减少执行过程中的判断(`if`), 一次生成需要的对象. 缺点是对象被创建保存在内存;

```js
//例1
var SingleByEnv = (function(){
  var objA = {
    method: function(){}
  }
  var objB = {
    method: function(){}
  }
  //nodejs环境返回objA, 否则返回objB
  return typeof global !== 'undefined' ? objA : objB;
})();

//例2
var simpleXhrFactory = (function(){
  var methods = [
    function() {
      return new XMLHttpRequest();
    },
    function() {
      return new ActiveXObject('Msxml2.XMLHTTP');
    },
    function() {
      return new ActiveXObject('Microsoft.XMLHTTP');
    }
  ];
  
  for(var i = 0, len = methods.length; i < len; i++) {
    try {
      results[i]();
    } catch(error) {
      continue;
    }
    this.createXhrObject = methods[i];
    return methods[i];
  }

  throw new Error('SimpleHandler: could not create an XHR object.');
})()
```


# 工厂模式
Interface/接口 在工厂模式中起重要的作用, 没有类型检查, 工厂模式生成的对象无法保证;

1. 简单工厂模式
2. 工厂模式

## 简单工厂模式
```js
var BicycleShop = function() {
  BicycleShop.prototype = {
    sellBicycle: function(model) {
      var bicycle = BicycleFactory.createBicycle(model);

      bicycle.assemble();
      bicycle.wash();

      return bicycle;
    }
  }
}
//需要的对象统一由对象工厂处理;
//需要对生成的对象做好接口检查;
var BicycleInterface = new Interface('Bicycle', ['assemble', 'wash', 'ride', 'repaire']);
var BicycleFactory = {
  createBicycle: function(model) {
    var bicycle;

    switch(model) {
      case 'shanghai':
        bicycle = new Shanghai();
        break;
      case 'moren':
      default:
        bicycle = new Moren();
    }
    Interface.ensureImplements(bicycle, BicycleInterface);
    return bicycle;
  }
}
```


## 工厂模式
真正的工厂模式的与简单工厂模式的区别: 它不是另外使用一个类(上面的BicycleFactory)或对象来创建需要的对象, 而是使用一个子类.





## 工厂模式**适用场合**
1. **动态实现**
创建一些用不同方式实现同一接口的对象

2. **节省设置开销**
把设置工作集中在工厂而不是各个类的构造函数; 
如可以在上面的`BicycleFactory`中添加生成的对象的初始化设置;

3. **用许多小型对象组成一个大对象**


## XHR: 简单工厂模式 + 专用型连接对象
前面使用单例模式实现了XHR方法, 下面使用工厂方法实现, 但由于不是单例, 所以要加一种避免重复运行检测代码的方法`memoizing`
```js
var SimpleHandler = function() {};
SimpleHandler.prototype = {
  request: function(method, url, callback, postVars) {
    var xhr = this.createXhrObject();
    xhr.onreadstatechange = function() {
      if (xhr.readyState !== 4 ) return;
      (xhr.status == 200) ?
        callback.success(xhr.responseText, xhr.responseXML) :
        callback.failure(xhr.responseText, xhr.responseXML);
    }
    xhr.open(method, url, true);
    if(method !== 'POST') postVars = null;
    xhr.send(postVars);
  },
  // 简单工厂模式(一次性)
  createXhrObject: function() {
    var methods = [
      function() {return new XMLHttpRequest();},
      function() {return new ActiveXObject('Msxml2.XMLHTTP');},
      function() {return new ActiveXObject('Microsoft.XMLHTTP');}
    ];
    
    for(var i = 0, len = methods.length; i < len; i++) {
      try {
        results[i]();
      } catch(error) {
        continue;
      }
      //重载: Memoize the method
      this.createXhrObject = methods[i];
      return methods[i];
    }

    throw new Error('SimpleHandler: could not create an XHR object.');
  }
}



var QueuedHandler = function() {
  //新增属性;
  this.queue = [];
  this.requestInProgress = false;
  this.retryDelay = 5;
}
QueuedHandler.prototype = Object.setPrototypeOf(SimpleHandler.prototype);
QueuedHandler.prototype.request = function(method, url, callback, postVars, override) {
  if(this.requestInProgress && !override) {
    this.queue.push({
      method: method,
      url: url,
      callback: callback,
      postVars: postVars
    });
  } else {
    this.requestInProgress = true;
    var xhr = this.createXhrObject();
    var that = this;
    xhr.onreadystatechange = function() {
      if (xhr.readState !== 4) return;
      if (xhr.status === 200) {
        callback.success(xhr.responseText, xhr.responseXML);
        that.advanceQueue();
      } else {
        callback.failure(xhr.status);
        setTimeout(function() {
          that.request(method, url, callback, postVars, true)
        }, that.retryDelay * 1000)
      }
    }
    xhr.open(method, url, true);
    if(method !== 'POST') postVars = null;
    xhr.send(postVars);
  }
}  

QueuedHandler.prototype.advanceQueue = function() {
  if (this.queue.length === 0 ) {
    this.requestInProgress = false;
    return;
  }
  var req = this.queue.shift();
  this.request(req.method, req.url, req.callback, req.postVars, true);
}

```
